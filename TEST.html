<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Viewport meta tag ensures mobile devices display the page at the device width -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Sticker Pack Picture Editor</title>
  <style>
    /* Remove default margins and allow scrolling if needed */
    html, body {
      margin: 0;
      padding: 0;
      background: #333;
      width: 100vw;
      height: 100vh;
      overflow: auto;
    }
    /* Container to centre the canvas both horizontally and vertically */
.canvas-container {
    position: absolute;
    top: 10px;
    right: 10px;
    bottom: 10px;
    left: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
}
    /* The canvas now has rounded edges and a subtle shadow for a minimal aesthetic */
    canvas {
      max-width: 100%;
      height: auto;
      display: block;
      background: #000;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <div class="canvas-container">
    <!-- Original fixed-size canvas: 681 x 840 -->
    <canvas id="gameCanvas" width="681" height="840"></canvas>
  </div>
  <script>
    // ============================================================
    // DESIGN RESOLUTION AND LAYOUT CONSTANTS (original values)
    // ============================================================
    const DESIGN_WIDTH  = 681;
    const DESIGN_HEIGHT = 840;
    // In the design, the sidebar occupies 249px on the right.
    const SIDEBAR_WIDTH = 249;
    const MAIN_AREA_WIDTH = DESIGN_WIDTH - SIDEBAR_WIDTH; // 432

    // ------------------------------------------------------------
    // Global variable for scale factor used for transforming mouse/touch events.
    // ------------------------------------------------------------
    let currentScale = 1;

    // Variables for background panning with touch
    let lastTouchX = null, lastTouchY = null;

    // ------------------------------------------------------------
    // Canvas Setup
    // ------------------------------------------------------------
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // ------------------------------------------------------------
    // Helper function to draw a rounded rectangle.
    // You can specify different radii for each corner.
    // ------------------------------------------------------------
    function drawRoundedRect(x, y, width, height, radiusTL, radiusTR, radiusBR, radiusBL) {
      ctx.beginPath();
      ctx.moveTo(x + radiusTL, y);
      ctx.lineTo(x + width - radiusTR, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radiusTR);
      ctx.lineTo(x + width, y + height - radiusBR);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radiusBR, y + height);
      ctx.lineTo(x + radiusBL, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radiusBL);
      ctx.lineTo(x, y + radiusTL);
      ctx.quadraticCurveTo(x, y, x + radiusTL, y);
      ctx.closePath();
      ctx.fill();
    }

    // ------------------------------------------------------------
    // Global State Variables (unchanged)
    // ------------------------------------------------------------
    let backgroundX = 0, backgroundY = 0;
    let toggleDragEnabled = false;
    let toggleBorderOn = true;
    let currentSwatchIndex = 0;
    let selectedColor = "rgb(0,0,0)";

    // Circle data and dragging
    let circleInstances = [];
    let dragging = false;
    let draggedItem = null;
    let offsetX = 0, offsetY = 0;

    const circleRadius = 50;
    const smallCircleRadius = Math.floor(circleRadius / 3);
    const initialCirclePositions = [{ x: DESIGN_WIDTH - 190, y: 350 }];
    const initialMediumCirclePositions = [{ x: DESIGN_WIDTH - 92, y: 350 }];
    const initialSmallCirclePositions = [{ x: DESIGN_WIDTH - 30, y: 350 }];

    // ------------------------------------------------------------
    // Colour Swatches & UI Buttons (using design coordinates)
    // ------------------------------------------------------------
    const colorSwatches = [
      [255, 0, 0], [255, 102, 102], [204, 0, 0], [255, 128, 128],
      [255, 165, 0], [255, 178, 102], [255, 128, 0],
      [255, 255, 0], [255, 255, 102], [204, 204, 0], [255, 255, 128],
      [0, 255, 0], [102, 255, 102], [0, 204, 0], [128, 255, 128],
      [0, 255, 255], [0, 128, 128], [102, 255, 255], [0, 204, 204],
      [0, 0, 255], [102, 178, 255], [0, 128, 255], [128, 128, 255],
      [102, 102, 255], [51, 51, 153], [128, 0, 128], [178, 102, 255], [102, 0, 204],
      [255, 0, 255], [255, 192, 203], [255, 153, 204], [255, 102, 178],
      [165, 42, 42], [128, 128, 0], [128, 128, 64], [64, 128, 128],
      [255, 255, 255], [0, 0, 0], [192, 192, 192], [160, 160, 160],
      [128, 128, 128], [96, 96, 96], [64, 64, 64], [32, 32, 32], [16, 16, 16],
      [224, 224, 224], [128, 128, 160]
    ];
    const swatchWidth = 30, swatchHeight = 30;
    let swatchPositions = [];
    const rows = 9, cols = 6;
    for (let i = 0; i < colorSwatches.length; i++) {
      let row = Math.floor(i / cols);
      let col = i % cols;
      let x = DESIGN_WIDTH - 215 + col * (swatchWidth + 1);
      // Increased starting y from 20 to 40 so the swatches don't overlap the new text
      let y = 40 + row * (swatchHeight + 1);
      swatchPositions.push({ x, y });
    }

    const resetButton    = { x: DESIGN_WIDTH - 120, y: DESIGN_HEIGHT - 110, w: 50,  h: 50,  colour: "rgb(100,100,100)", label: "RC" };
    const resetBgButton  = { x: DESIGN_WIDTH - 70,  y: DESIGN_HEIGHT - 110, w: 50,  h: 50,  colour: "rgb(100,100,100)", label: "RBG" };
    const deleteButton   = { x: DESIGN_WIDTH - 230, y: DESIGN_HEIGHT - 210, w: 100, h: 180, colour: "rgb(100,100,100)", label: "Delete" };
    const randomButton   = { x: DESIGN_WIDTH - 120, y: DESIGN_HEIGHT - 210, w: 100, h: 50,  colour: "rgb(100,100,100)", label: "Random" };
    const saveButton     = { x: DESIGN_WIDTH - 120, y: DESIGN_HEIGHT - 60,  w: 100, h: 50,  colour: "rgb(100,100,100)", label: "Save" };
    const backgroundButton = { x: DESIGN_WIDTH - 120, y: DESIGN_HEIGHT - 160, w: 100, h: 50, colour: "rgb(100,100,100)", label: "New BG" };

    let switchButtons = [];
    const firstColumnX = DESIGN_WIDTH - 230;
    const secondColumnX = DESIGN_WIDTH - 120;
    const baseY = DESIGN_HEIGHT - 420;
    for (let i = 1; i <= 13; i++) {
      let col = (i % 2 === 1) ? firstColumnX : secondColumnX;
      let index = Math.floor((i - 1) / 2);
      let y = baseY + index * 25;
      switchButtons.push({ x: col, y: y, w: 100, h: 20, colour: "rgb(100,100,100)", label: "Pattern " + i, patternNumber: i });
    }

    const toggleDragButton = { x: DESIGN_WIDTH - 120, y: DESIGN_HEIGHT - 260, w: 100, h: 50, colour: "rgb(100,100,100)", label: "BG Move Off" };
    const toggleBorderButton = { x: 470, y: 810, w: 80, h: 20, colour: "rgb(100,100,100)", label: "Border On" };

    // ============================================================
    // Pattern Functions with random colour choices for specified patterns
    // (All pattern functions remain unchanged.)
    // ============================================================
    function Pattern1(low_width, low_height) {
      let offCanvas = document.createElement("canvas");
      offCanvas.width = low_width;
      offCanvas.height = low_height;
      let offCtx = offCanvas.getContext("2d");
      let imageData = offCtx.createImageData(low_width, low_height);
      let phase1 = Math.random() * 5 * Math.PI;
      let phase2 = Math.random() * 5 * Math.PI;
      let freq1 = Math.random() * (8 - 1) + 1;
      let freq2 = Math.random() * (8 - 1) + 1;
      let amp1 = Math.random() * (0.5 - 0.01) + 0.01;
      let amp2 = Math.random() * (0.5 - 0.01) + 0.01;
      // Generate two random colours
      const colour1 = [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
      const colour2 = [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
      const rArray = new Float32Array(low_width * low_height);
      let index = 0, max_r = 0;
      for (let i = 0; i < low_height; i++) {
        let y = -1 + 2 * i / (low_height - 1);
        for (let j = 0; j < low_width; j++) {
          let x = -1 + 2 * j / (low_width - 1);
          let r = Math.sqrt(x * x + y * y);
          let theta = Math.atan2(y, x);
          r += amp1 * Math.sin(freq1 * theta + phase1);
          r += amp2 * Math.sin(freq2 * theta + phase2);
          rArray[index] = r;
          if (r > max_r) max_r = r;
          index++;
        }
      }
      index = 0;
      for (let i = 0; i < low_height; i++) {
        for (let j = 0; j < low_width; j++) {
          let t = Math.min(Math.max(rArray[index] / max_r, 0), 1);
          let colour = (t < 0.5) ? colour1 : colour2;
          let pixelIndex = index * 4;
          imageData.data[pixelIndex] = colour[0];
          imageData.data[pixelIndex + 1] = colour[1];
          imageData.data[pixelIndex + 2] = colour[2];
          imageData.data[pixelIndex + 3] = 255;
          index++;
        }
      }
      offCtx.putImageData(imageData, 0, 0);
      return offCanvas;
    }

    function Pattern2(low_width, low_height) {
      let canvas = document.createElement("canvas");
      canvas.width = low_width;
      canvas.height = low_height;
      let ctx = canvas.getContext("2d");
      const numLayers = 4;
      // Generate random colours for each layer
      const colours = [];
      for (let i = 0; i < numLayers; i++) {
        colours.push([Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)]);
      }
      const rArr = new Float32Array(low_width * low_height);
      const gArr = new Float32Array(low_width * low_height);
      const bArr = new Float32Array(low_width * low_height);
      for (let layer = 0; layer < numLayers; layer++) {
        let phase = Math.random() * 2 * Math.PI;
        let freq = Math.random() * (0.091 - 0.02) + 0.02;
        let index = 0;
        for (let i = 0; i < low_height; i++) {
          let wave = Math.sin(2 * freq * i + phase);
          for (let j = 0; j < low_width; j++) {
            let checker = (((Math.floor(j / 150)) % 2) + ((Math.floor(i / 50)) % 2)) % 2;
            checker = checker * 2 - 1;
            let combined = checker * wave;
            let normalised = (combined + 1) / 2;
            rArr[index] = Math.max(rArr[index], colours[layer][0] * normalised);
            gArr[index] = Math.max(gArr[index], colours[layer][1] * normalised);
            bArr[index] = Math.max(bArr[index], colours[layer][2] * normalised);
            index++;
          }
        }
      }
      let imageData = ctx.createImageData(low_width, low_height);
      for (let i = 0; i < low_width * low_height; i++) {
        let idx = i * 4;
        imageData.data[idx] = Math.round(rArr[i]);
        imageData.data[idx + 1] = Math.round(gArr[i]);
        imageData.data[idx + 2] = Math.round(bArr[i]);
        imageData.data[idx + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
      return canvas;
    }

    function Pattern3(low_width, low_height) {
      let canvas = document.createElement("canvas");
      canvas.width = low_width;
      canvas.height = low_height;
      let ctx = canvas.getContext("2d");
      let imageData = ctx.createImageData(low_width, low_height);
      let phase1 = Math.random() * 2 * Math.PI;
      let phase2 = Math.random() * 2 * Math.PI;
      let freq1 = Math.random() * (0.09 - 0.00001) + 0.00001;
      let freq2 = Math.random() * (0.09 - 0.00001) + 0.00001;
      // Generate two random colours
      const colour1 = [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
      const colour2 = [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
      let index = 0;
      for (let i = 0; i < low_height; i++) {
        for (let j = 0; j < low_width; j++) {
          let sine_val = Math.sin(freq1 * i + phase1) * Math.cos(freq1 * j + phase1);
          let cos_val = Math.cos(freq2 * j + phase2) * Math.sin(freq2 * i + phase2);
          let pattern = (sine_val + cos_val > 0);
          let colour = pattern ? colour1 : colour2;
          let idx = index * 4;
          imageData.data[idx] = colour[0];
          imageData.data[idx + 1] = colour[1];
          imageData.data[idx + 2] = colour[2];
          imageData.data[idx + 3] = 255;
          index++;
        }
      }
      ctx.putImageData(imageData, 0, 0);
      return canvas;
    }

    function Pattern4(low_width, low_height) {
      let canvas = document.createElement("canvas");
      canvas.width = low_width;
      canvas.height = low_height;
      let ctx = canvas.getContext("2d");
      const numLayers = 2;
      const grayArr = new Float32Array(low_width * low_height);
      for (let layer = 0; layer < numLayers; layer++) {
        let phase = Math.random() * 2 * Math.PI;
        let freq = Math.random() * (0.05 - 0.0001) + 0.0001;
        let waveTypes = [
          Math.sin,
          Math.cos,
          Math.tan,
          function(z) { return Math.sign(Math.sin(z)); }
        ];
        let indices = [];
        while (indices.length < 2) {
          let r = Math.floor(Math.random() * waveTypes.length);
          if (!indices.includes(r)) indices.push(r);
        }
        let wave_func1 = waveTypes[indices[0]];
        let wave_func2 = waveTypes[indices[1]];
        let combined = new Float32Array(low_width * low_height);
        let minVal = Infinity, maxVal = -Infinity;
        let index = 0;
        for (let i = 0; i < low_height; i++) {
          for (let j = 0; j < low_width; j++) {
            let val1 = wave_func1(freq * i + phase);
            let val2 = wave_func2(freq * j + phase);
            let comb = val1 + val2;
            combined[index] = comb;
            if (comb < minVal) minVal = comb;
            if (comb > maxVal) maxVal = comb;
            index++;
          }
        }
        index = 0;
        for (let i = 0; i < low_height; i++) {
          for (let j = 0; j < low_width; j++) {
            let normalized = (combined[index] - minVal) / (maxVal - minVal);
            let intensity = normalized * 255;
            grayArr[index] = Math.max(grayArr[index], intensity);
            index++;
          }
        }
      }
      let imageData = ctx.createImageData(low_width, low_height);
      for (let i = 0; i < low_width * low_height; i++) {
        let val = Math.round(grayArr[i]);
        let idx = i * 4;
        imageData.data[idx] = val;
        imageData.data[idx + 1] = val;
        imageData.data[idx + 2] = val;
        imageData.data[idx + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
      return canvas;
    }

    function Pattern5(low_width, low_height) {
      let canvas = document.createElement("canvas");
      canvas.width = low_width;
      canvas.height = low_height;
      let ctx = canvas.getContext("2d");
      const numLayers = 4;
      const colors = [
        [255, 0, 0],
        [0, 255, 0],
        [0, 0, 255],
        [0, 255, 255]
      ];
      const rArr = new Float32Array(low_width * low_height);
      const gArr = new Float32Array(low_width * low_height);
      const bArr = new Float32Array(low_width * low_height);
      for (let layer = 0; layer < numLayers; layer++) {
        let phase = Math.random() * 2 * Math.PI;
        let freq = Math.random() * (0.01 - 0.005) + 0.005;
        let combined = new Float32Array(low_width * low_height);
        let minVal = Infinity, maxVal = -Infinity;
        let index = 0;
        for (let i = 0; i < low_height; i++) {
          for (let j = 0; j < low_width; j++) {
            let val = Math.sin(freq * (j + i) + phase);
            combined[index] = val;
            if (val < minVal) minVal = val;
            if (val > maxVal) maxVal = val;
            index++;
          }
        }
        index = 0;
        for (let i = 0; i < low_height; i++) {
          for (let j = 0; j < low_width; j++) {
            let normalized = (combined[index] - minVal) / (maxVal - minVal);
            rArr[index] = Math.max(rArr[index], colors[layer][0] * normalized);
            gArr[index] = Math.max(gArr[index], colors[layer][1] * normalized);
            bArr[index] = Math.max(bArr[index], colors[layer][2] * normalized);
            index++;
          }
        }
      }
      let imageData = ctx.createImageData(low_width, low_height);
      for (let i = 0; i < low_width * low_height; i++) {
        let idx = i * 4;
        imageData.data[idx] = Math.round(rArr[i]);
        imageData.data[idx + 1] = Math.round(gArr[i]);
        imageData.data[idx + 2] = Math.round(bArr[i]);
        imageData.data[idx + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
      return canvas;
    }

    function Pattern6(low_width, low_height, num_curves = 4) {
      let canvas = document.createElement("canvas");
      canvas.width = low_width;
      canvas.height = low_height;
      let ctx = canvas.getContext("2d");
      let imageData = ctx.createImageData(low_width, low_height);
      // Generate two random colours
      const colour1 = [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
      const colour2 = [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
      const A = low_width / 2, B = low_height / 2;
      const x_coords = new Float32Array(low_width);
      for (let j = 0; j < low_width; j++) {
        x_coords[j] = -A + (2 * A * j) / (low_width - 1);
      }
      const y_coords = new Float32Array(low_height);
      for (let i = 0; i < low_height; i++) {
        y_coords[i] = -B + (2 * B * i) / (low_height - 1);
      }
      const count_above = new Uint8Array(low_width * low_height);
      for (let k = 0; k < num_curves; k++) {
        let a = Math.random() * (5 - 1) + 1;
        let b = Math.random() * (5 - 1) + 1;
        let delta = Math.random() * 2 * Math.PI;
        for (let j = 0; j < low_width; j++) {
          let t = Math.asin(x_coords[j] / A) / a - delta;
          let y_lissajous = B * Math.sin(b * t);
          for (let i = 0; i < low_height; i++) {
            let index = i * low_width + j;
            if (y_coords[i] < y_lissajous) count_above[index]++;
          }
        }
      }
      let index = 0;
      for (let i = 0; i < low_height; i++) {
        for (let j = 0; j < low_width; j++) {
          let colour = (count_above[index] % 2 === 0) ? colour1 : colour2;
          let idx = index * 4;
          imageData.data[idx] = colour[0];
          imageData.data[idx + 1] = colour[1];
          imageData.data[idx + 2] = colour[2];
          imageData.data[idx + 3] = 255;
          index++;
        }
      }
      ctx.putImageData(imageData, 0, 0);
      return canvas;
    }

    function Pattern7(low_width, low_height, num_curves = 4) {
      let canvas = document.createElement("canvas");
      canvas.width = low_width;
      canvas.height = low_height;
      let ctx = canvas.getContext("2d");
      let imageData = ctx.createImageData(low_width, low_height);
      // Generate two random colours for gradient interpolation
      const colour1 = [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
      const colour2 = [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
      const A = low_width / 2, B = low_height / 2;
      const x_coords = new Float32Array(low_width);
      for (let j = 0; j < low_width; j++) {
        x_coords[j] = -A + (2 * A * j) / (low_width - 1);
      }
      const y_coords = new Float32Array(low_height);
      for (let i = 0; i < low_height; i++) {
        y_coords[i] = -B + (2 * B * i) / (low_height - 1);
      }
      const count_above = new Uint8Array(low_width * low_height);
      for (let k = 0; k < num_curves; k++) {
        let a = Math.random() * (5 - 1) + 1;
        let b = Math.random() * (5 - 1) + 1;
        let delta = Math.random() * 2 * Math.PI;
        for (let j = 0; j < low_width; j++) {
          let t = Math.asin(Math.max(-1, Math.min(1, x_coords[j] / A))) / a - delta;
          let y_lissajous = B * Math.sin(b * t);
          for (let i = 0; i < low_height; i++) {
            let index = i * low_width + j;
            if (y_coords[i] < y_lissajous) count_above[index]++;
          }
        }
      }
      const gradient = new Float32Array(low_height);
      const inverted_gradient = new Float32Array(low_height);
      for (let i = 0; i < low_height; i++) {
        let val = i / (low_height - 1);
        gradient[i] = val;
        inverted_gradient[i] = 1 - val;
      }
      let index = 0;
      for (let i = 0; i < low_height; i++) {
        for (let j = 0; j < low_width; j++) {
          // Determine interpolation factor based on count_above value and row gradient
          let factor = (count_above[index] % 2 === 0) ? inverted_gradient[i] : gradient[i];
          // Interpolate between colour1 and colour2
          let r = Math.round(colour1[0] * (1 - factor) + colour2[0] * factor);
          let g = Math.round(colour1[1] * (1 - factor) + colour2[1] * factor);
          let b = Math.round(colour1[2] * (1 - factor) + colour2[2] * factor);
          let idx = index * 4;
          imageData.data[idx] = r;
          imageData.data[idx + 1] = g;
          imageData.data[idx + 2] = b;
          imageData.data[idx + 3] = 255;
          index++;
        }
      }
      ctx.putImageData(imageData, 0, 0);
      return canvas;
    }

    function Pattern8(surface_width, surface_height) {
      let canvas = document.createElement("canvas");
      canvas.width = surface_width;
      canvas.height = surface_height;
      let ctx = canvas.getContext("2d");
      // Generate random background and foreground colours
      const bgRGB = [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
      const fgRGB = [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
      const bgColour = "rgb(" + bgRGB.join(",") + ")";
      const fgColour = "rgb(" + fgRGB.join(",") + ")";
      ctx.fillStyle = bgColour;
      ctx.fillRect(0, 0, surface_width, surface_height);
      const cell_size = 120;
      const cols = Math.floor(surface_width / cell_size);
      const rows = Math.floor(surface_height / cell_size);
      function draw_wave_fragment(x, y, width, height) {
        let waveCanvas = document.createElement("canvas");
        waveCanvas.width = width;
        waveCanvas.height = height;
        let waveCtx = waveCanvas.getContext("2d");
        waveCtx.fillStyle = bgColour;
        waveCtx.fillRect(0, 0, width, height);
        let freq = Math.random() * (0.2 - 0.05) + 0.05;
        let amp = Math.floor(height / 4);
        let phase = Math.random() * 2 * Math.PI;
        waveCtx.fillStyle = fgColour;
        for (let i = 0; i < width; i++) {
          let sine_value = Math.sin(freq * i + phase);
          let wave_y = Math.floor(height / 2 + sine_value * amp);
          waveCtx.beginPath();
          waveCtx.arc(i, wave_y, Math.floor(height / 10), 0, Math.PI * 2);
          waveCtx.fill();
        }
        let angles = [0, 90, 180, 270];
        let angle = angles[Math.floor(Math.random() * angles.length)];
        let rotatedCanvas = document.createElement("canvas");
        if (angle % 180 === 0) {
          rotatedCanvas.width = width;
          rotatedCanvas.height = height;
        } else {
          rotatedCanvas.width = height;
          rotatedCanvas.height = width;
        }
        let rCtx = rotatedCanvas.getContext("2d");
        rCtx.translate(rotatedCanvas.width / 2, rotatedCanvas.height / 2);
        rCtx.rotate(angle * Math.PI / 180);
        rCtx.drawImage(waveCanvas, -width / 2, -height / 2);
        let centerX = x + width / 2;
        let centerY = y + height / 2;
        let drawX = centerX - rotatedCanvas.width / 2;
        let drawY = centerY - rotatedCanvas.height / 2;
        ctx.drawImage(rotatedCanvas, drawX, drawY);
      }
      for (let col = 0; col < cols; col++) {
        for (let row = 0; row < rows; row++) {
          if (Math.random() > 0.2) {
            let x = col * cell_size;
            let y = row * cell_size;
            draw_wave_fragment(x, y, cell_size, cell_size);
          }
        }
      }
      return canvas;
    }

    function Pattern9(surface_width, surface_height) {
      let canvas = document.createElement("canvas");
      canvas.width = surface_width;
      canvas.height = surface_height;
      let ctx = canvas.getContext("2d");

      // Generate an array of 5 random colours
      let colors = [];
      for (let i = 0; i < 5; i++) {
        colors.push([
          Math.floor(Math.random() * 256),
          Math.floor(Math.random() * 256),
          Math.floor(Math.random() * 256)
        ]);
      }

      // Choose a random background colour from the generated palette
      let bgColor = colors[Math.floor(Math.random() * colors.length)];
      ctx.fillStyle = "rgb(" + bgColor.join(",") + ")";
      ctx.fillRect(0, 0, surface_width, surface_height);

      const tile_width = 50, tile_height = 50;
      for (let y = 0; y < surface_height; y += tile_width) {
        for (let x = 0; x < surface_width; x += tile_height) {
          // For each tile, pick a random colour from the palette
          let col = colors[Math.floor(Math.random() * colors.length)];
          ctx.fillStyle = "rgb(" + col.join(",") + ")";
          ctx.fillRect(x, y, tile_width, tile_height);
        }
      }

      let offset = 9;
      let chromaticCanvas = document.createElement("canvas");
      chromaticCanvas.width = surface_width;
      chromaticCanvas.height = surface_height;
      let chromCtx = chromaticCanvas.getContext("2d");
      chromCtx.globalCompositeOperation = "screen";
      let offsets = [-offset, 0, offset];
      offsets.forEach(off => { chromCtx.drawImage(canvas, off, 0); });
      for (let y = 0; y < surface_width; y += 2) {
        chromCtx.fillStyle = "rgba(0,0,0,0.5)";
        chromCtx.fillRect(0, y, surface_width, 1);
      }
      return chromaticCanvas;
    }

    function Pattern10(surface_width, surface_height) {
      let canvas = document.createElement("canvas");
      canvas.width = surface_width;
      canvas.height = surface_height;
      let ctx = canvas.getContext("2d");
      function adjust_color_brightness(color, factor) {
        return color.map(c => Math.min(Math.floor(c * factor), 255));
      }
      function enlarge_triangle(triangle, scale_factor = 1.1) {
        let centroid = [0, 0];
        triangle.forEach(pt => { centroid[0] += pt[0]; centroid[1] += pt[1]; });
        centroid[0] /= triangle.length;
        centroid[1] /= triangle.length;
        return triangle.map(pt => [centroid[0] + (pt[0] - centroid[0]) * scale_factor,
                                     centroid[1] + (pt[1] - centroid[1]) * scale_factor]);
      }
      function draw_triangle_with_shadow_and_noise(triangle, base_color, shadow_offset = [10, 10], shadow_color = "rgba(0,0,0,0.5)", scale_factor = 1.15) {
        let enlarged = enlarge_triangle(triangle, scale_factor);
        let shadowTriangle = enlarged.map(pt => [pt[0] + shadow_offset[0], pt[1] + shadow_offset[1]]);
        ctx.fillStyle = shadow_color;
        ctx.beginPath();
        ctx.moveTo(shadowTriangle[0][0], shadowTriangle[0][1]);
        shadowTriangle.slice(1).forEach(pt => ctx.lineTo(pt[0], pt[1]));
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = "rgb(" + base_color.join(",") + ")";
        ctx.beginPath();
        ctx.moveTo(triangle[0][0], triangle[0][1]);
        triangle.slice(1).forEach(pt => ctx.lineTo(pt[0], pt[1]));
        ctx.closePath();
        ctx.fill();
      }
      function draw_fullscreen_triangles(base_color) {
        const width = surface_width, height = surface_height;
        let div_points = [];
        for (let i = 0; i < 3; i++) {
          div_points.push(Math.floor(Math.random() * (height - 1)) + 1);
        }
        div_points.sort((a, b) => a - b);
        div_points = [0].concat(div_points).concat([height]);
        let triangle_tips = [];
        for (let i = 0; i < 3; i++) {
          triangle_tips.push(Math.floor(Math.random() * (width - 1)) + 1);
        }
        let triangles = [];
        for (let i = 0; i < 3; i++) {
          const top_y = div_points[i], mid_y = div_points[i + 1], bot_y = div_points[i + 2];
          const tip_x = triangle_tips[i];
          triangles.push([[0, top_y], [tip_x, mid_y], [0, bot_y]]);
          triangles.push([[width, top_y], [tip_x, mid_y], [width, bot_y]]);
        }
        triangles.sort((a, b) => ((a[0][1] + a[1][1] + a[2][1]) / 3) - ((b[0][1] + b[1][1] + b[2][1]) / 3));
        triangles.forEach(triangle => {
          const avg_y = (triangle[0][1] + triangle[1][1] + triangle[2][1]) / 3;
          const brightness_factor = 0.5 + 0.5 * (avg_y / height);
          const color = adjust_color_brightness(base_color, brightness_factor);
          draw_triangle_with_shadow_and_noise(triangle, color);
        });
      }
      function create_noise_background(base_color, intensity = 10, alpha = 0.2) {
        ctx.fillStyle = "rgb(" + base_color.join(",") + ")";
        ctx.fillRect(0, 0, surface_width, surface_height);
        let imageData = ctx.getImageData(0, 0, surface_width, surface_height);
        for (let i = 0; i < imageData.data.length; i += 4) {
          let noise = Math.floor((Math.random() - 0.5) * intensity);
          imageData.data[i] = Math.min(255, Math.max(0, imageData.data[i] + noise));
          imageData.data[i + 1] = Math.min(255, Math.max(0, imageData.data[i + 1] + noise));
          imageData.data[i + 2] = Math.min(255, Math.max(0, imageData.data[i + 2] + noise));
        }
        ctx.putImageData(imageData, 0, 0);
      }
      const dark_greys = [[20, 20, 20], [30, 30, 30], [40, 40, 40]];
      const dark_greens = [[50, 100, 50], [0, 60, 20], [0, 70, 30]];
      const dark_blues = [[50, 50, 50], [50, 50, 60], [20, 20, 70]];
      const background_colors = dark_greys.concat(dark_greens, dark_blues);
      const background_color = background_colors[Math.floor(Math.random() * background_colors.length)];
      create_noise_background(background_color, 5, 1);
      const a_palette = [
        [89, 79, 191],
        [204, 119, 34],
        [102, 153, 204],
        [129, 97, 131],
        [217, 145, 157],
        [156, 105, 38],
        [76, 153, 0]
      ];
      const triangle_color = a_palette[Math.floor(Math.random() * a_palette.length)];
      draw_fullscreen_triangles(triangle_color);
      return canvas;
    }

    function Pattern11(surface_width, surface_height) {
      let canvas = document.createElement("canvas");
      canvas.width = surface_width;
      canvas.height = surface_height;
      let ctx = canvas.getContext("2d");
      let rule_number = Math.floor(Math.random() * 256);
      let rule = rule_number.toString(2).padStart(8, '0');
      let reversedRule = rule.split("").reverse().join("");
      let rule_dict = {};
      for (let i = 0; i < 8; i++) {
        let key = i.toString(2).padStart(3, '0');
        rule_dict[key] = reversedRule[i];
      }
      let current_row = [];
      for (let x = 0; x < surface_width; x++) {
        current_row.push(Math.random() < 0.5 ? '0' : '1');
      }
      for (let y = 0; y < surface_height; y++) {
        for (let x = 0; x < surface_width; x++) {
          ctx.fillStyle = current_row[x] === '1' ? "black" : "white";
          ctx.fillRect(x, y, 1, 1);
        }
        let next_row = [];
        for (let x = 0; x < surface_width; x++) {
          let left = x - 1 >= 0 ? current_row[x - 1] : '0';
          let center = current_row[x];
          let right = x + 1 < surface_width ? current_row[x + 1] : '0';
          let neighbourhood = left + center + right;
          let next_cell = rule_dict[neighbourhood] || '0';
          next_row.push(next_cell);
        }
        current_row = next_row;
      }
      let offset = Math.floor(Math.random() * 5) + 1;
      let chromaticCanvas = document.createElement("canvas");
      chromaticCanvas.width = surface_width;
      chromaticCanvas.height = surface_height;
      let chromCtx = chromaticCanvas.getContext("2d");
      chromCtx.globalCompositeOperation = "screen";
      let offsets = [-offset, 0, offset];
      offsets.forEach(off => { chromCtx.drawImage(canvas, off, 0); });
      for (let y = 0; y < surface_height; y += Math.floor(Math.random() * 3 + 2)) {
        chromCtx.fillStyle = "rgba(0,0,0,0.5)";
        chromCtx.fillRect(0, y, surface_width, 1);
      }
      return chromaticCanvas;
    }

    function Pattern12(low_width, low_height) {
      let canvas = document.createElement("canvas");
      canvas.width = low_width;
      canvas.height = low_height;
      let ctx = canvas.getContext("2d");
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, low_width, low_height);
      const background = [0, 0, 0];
      const white = [255, 255, 255];
      const mustard = [227, 207, 87];
      const coral = [255, 127, 80];
      const ultramarine = [18, 10, 143];
      function get_new_flower_pattern() {
        let petal_color = Math.random() < 0.5 ? mustard : (Math.random() < 0.5 ? coral : ultramarine);
        let center_color = white;
        return [
          [background, petal_color, background],
          [petal_color, center_color, petal_color],
          [background, petal_color, background]
        ];
      }
      function get_flower_pattern() {
        let pattern_choice = Math.floor(Math.random() * 3) + 1;
        if (pattern_choice === 1) return get_new_flower_pattern();
        else if (pattern_choice === 2) {
          return [
            [background, white, background],
            [white, Math.random() < 0.5 ? mustard : (Math.random() < 0.5 ? coral : ultramarine), white],
            [background, white, background]
          ];
        } else {
          let petal_color = Math.random() < 0.5 ? mustard : (Math.random() < 0.5 ? coral : ultramarine);
          return [
            [petal_color, background, petal_color],
            [background, petal_color, background],
            [petal_color, background, petal_color]
          ];
        }
      }
      function get_4x4_pattern() {
        let color = Math.random() < 0.5 ? mustard : (Math.random() < 0.5 ? coral : ultramarine);
        let pattern_4x4 = [
          [0, color, color, 0],
          [color, 0, 0, color],
          [color, 0, 0, color],
          [0, color, color, 0]
        ];
        return pattern_4x4.map(row => row.map(cell => cell === color ? color : background));
      }
      function draw_pattern(x, y, block_size, pattern) {
        for (let i = 0; i < pattern.length; i++) {
          for (let j = 0; j < pattern[i].length; j++) {
            let col = pattern[i][j];
            ctx.fillStyle = "rgb(" + col.join(",") + ")";
            ctx.fillRect(x + j * block_size, y + i * block_size, block_size, block_size);
          }
        }
      }
      const base_grid_spacing = Math.floor(Math.random() * (250 - 160)) + 160;
      for (let y = 0; y < low_height; y += base_grid_spacing) {
        for (let x = 0; x < low_width; x += base_grid_spacing) {
          if (Math.random() * 10 > 1) {
            let pattern_choice = Math.random() < 0.5 ? "3x3" : "4x4";
            let pattern, flower_size;
            if (pattern_choice === "3x3") {
              const sizes = [Math.floor(base_grid_spacing / 3), Math.floor(base_grid_spacing / 4), Math.floor(base_grid_spacing / 6)];
              flower_size = sizes[Math.floor(Math.random() * sizes.length)];
              pattern = get_flower_pattern();
            } else {
              flower_size = Math.floor(base_grid_spacing / 4);
              pattern = get_4x4_pattern();
            }
            const offsetX = x + base_grid_spacing / 2 - (pattern[0].length * flower_size) / 2;
            const offsetY = y + base_grid_spacing / 2 - (pattern.length * flower_size) / 2;
            draw_pattern(offsetX, offsetY, flower_size, pattern);
          }
        }
      }
      return canvas;
    }

    function Pattern13(surface_width, surface_height) {
      let canvas = document.createElement("canvas");
      canvas.width = surface_width;
      canvas.height = surface_height;
      let ctx = canvas.getContext("2d");
      // Generate random background and stroke colours
      const bgRGB = [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
      const strokeRGB = [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
      const bgColour = "rgb(" + bgRGB.join(",") + ")";
      const strokeColour = "rgb(" + strokeRGB.join(",") + ")";
      ctx.fillStyle = bgColour;
      ctx.fillRect(0, 0, surface_width, surface_height);
      const base_cell_size = 120;
      const cell_size_variations = [120, 180, 340];
      function draw_wave_fragment(x, y, width, height, angle, max_thickness = 12) {
        let waveCanvas = document.createElement("canvas");
        waveCanvas.width = width;
        waveCanvas.height = height;
        let waveCtx = waveCanvas.getContext("2d");
        waveCtx.fillStyle = bgColour;
        waveCtx.fillRect(0, 0, width, height);
        const freqs = [Math.random() * (0.3 - 0.05) + 0.05, Math.random() * (0.3 - 0.05) + 0.05];
        const phase = [Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI];
        const amp = Math.floor(height / 6);
        const points = [];
        for (let i = 0; i < width; i++) {
          let sum = 0;
          for (let k = 0; k < freqs.length; k++) {
            sum += Math.sin(freqs[k] * i + phase[k]);
          }
          let sine_value = sum / freqs.length;
          let wave_y = Math.floor(height / 2 + sine_value * amp);
          points.push([i, wave_y]);
        }
        waveCtx.strokeStyle = strokeColour;
        for (let i = 1; i < points.length; i++) {
          let dynamic_thickness = Math.max(1, Math.floor(4 + Math.abs(Math.sin(freqs[0] * i + phase[0]) * max_thickness)));
          let taper_factor = Math.min(i, points.length - i, 20) / 20.0;
          let adjusted_thickness = Math.max(1, Math.floor(dynamic_thickness * taper_factor));
          waveCtx.lineWidth = adjusted_thickness;
          waveCtx.beginPath();
          waveCtx.moveTo(points[i - 1][0], points[i - 1][1]);
          waveCtx.lineTo(points[i][0], points[i][1]);
          waveCtx.stroke();
        }
        let rotatedCanvas = document.createElement("canvas");
        if (angle % 180 === 0) {
          rotatedCanvas.width = width;
          rotatedCanvas.height = height;
        } else {
          rotatedCanvas.width = height;
          rotatedCanvas.height = width;
        }
        let rCtx = rotatedCanvas.getContext("2d");
        rCtx.translate(rotatedCanvas.width / 2, rotatedCanvas.height / 2);
        rCtx.rotate(angle * Math.PI / 180);
        rCtx.drawImage(waveCanvas, -width / 2, -height / 2);
        ctx.drawImage(rotatedCanvas, x, y);
      }
      let x = 0, y = 0;
      while (y < surface_height) {
        let cell_size = cell_size_variations[Math.floor(Math.random() * cell_size_variations.length)];
        if (x + cell_size > surface_width || y + cell_size > surface_height) {
          x = 0;
          y += cell_size;
          continue;
        }
        let max_thickness_variation = [8, 12, 16][Math.floor(Math.random() * 3)];
        if (Math.random() > 0.2) {
          let angle = (((x / base_cell_size) + (y / base_cell_size)) % 4) * 90;
          draw_wave_fragment(x, y, cell_size, cell_size, angle, max_thickness_variation);
        }
        x += cell_size;
        if (x >= surface_width) {
          x = 0;
          y += cell_size;
        }
      }
      return canvas;
    }

    // ------------------------------------------------------------
    // Store pattern functions in an array (order 1–13)
    // ------------------------------------------------------------
    const patternFunctions = [
      Pattern1, Pattern2, Pattern3, Pattern4, Pattern5, Pattern6,
      Pattern7, Pattern8, Pattern9, Pattern10, Pattern11, Pattern12, Pattern13
    ];
    // Use MAIN_AREA_WIDTH so that patterns fill the left side.
    let currentPatternFunction = patternFunctions[Math.floor(Math.random() * patternFunctions.length)];
    let checkerboardImg = currentPatternFunction(MAIN_AREA_WIDTH, DESIGN_HEIGHT);

    function createNewPattern() {
      checkerboardImg = currentPatternFunction(MAIN_AREA_WIDTH, DESIGN_HEIGHT);
    }

    function switchToPattern(patternNumber) {
      if (patternNumber >= 1 && patternNumber <= patternFunctions.length) {
        currentPatternFunction = patternFunctions[patternNumber - 1];
        checkerboardImg = currentPatternFunction(MAIN_AREA_WIDTH, DESIGN_HEIGHT);
      }
    }

    // ------------------------------------------------------------
    // Add random circles (only within the main drawing area)
    // ------------------------------------------------------------
    function addRandomCircles() {
      for (let i = 0; i < 5; i++) {
        const sizes = [circleRadius, Math.floor(circleRadius * 0.75), smallCircleRadius];
        let size = sizes[Math.floor(Math.random() * sizes.length)];
        let col = colorSwatches[Math.floor(Math.random() * colorSwatches.length)];
        let color = "rgb(" + col.join(",") + ")";
        let x = Math.random() * (MAIN_AREA_WIDTH - size);
        let y = Math.random() * (DESIGN_HEIGHT - size);
        circleInstances.push({ color, pos: { x, y }, radius: size });
      }
    }

    // ------------------------------------------------------------
    // Drawing routines with updated aesthetics
    // ------------------------------------------------------------
    // Draw colour swatches as rounded blocks.
    function drawColorSwatches() {
      for (let i = 0; i < colorSwatches.length; i++) {
        let pos = swatchPositions[i];
        let col = colorSwatches[i];
        ctx.fillStyle = "rgb(" + col.join(",") + ")";
        drawRoundedRect(pos.x, pos.y, swatchWidth, swatchHeight, 3, 3, 3, 3);
      }
    }

    // Draw a rounded button.
    // Added an optional overrideColour parameter.
    function drawButton(btn, overrideColour) {
      ctx.fillStyle = overrideColour || btn.colour;
      drawRoundedRect(btn.x, btn.y, btn.w, btn.h, 5, 5, 5, 5);
      ctx.fillStyle = "rgb(255,255,255)";
      ctx.font = "16px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2);
    }

    // Draw the toggle border button with rounded edges.
    function drawToggleButton() {
      ctx.fillStyle = toggleBorderOn ? "rgb(0,200,0)" : "rgb(100,100,100)";
      drawRoundedRect(toggleBorderButton.x, toggleBorderButton.y, toggleBorderButton.w, toggleBorderButton.h, 5, 5, 5, 5);
      ctx.fillStyle = "rgb(255,255,255)";
      ctx.font = "12px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      let text = toggleBorderOn ? "Border On" : "Border Off";
      ctx.fillText(text, toggleBorderButton.x + toggleBorderButton.w / 2, toggleBorderButton.y + toggleBorderButton.h / 2);
    }

    function drawInitialCircles() {
      ctx.save();
      initialCirclePositions.forEach(pos => {
        ctx.fillStyle = "rgba(43,43,43,1)";
        ctx.beginPath();
        ctx.arc(pos.x + 7, pos.y + 7, circleRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = selectedColor;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, circleRadius, 0, Math.PI * 2);
        ctx.fill();
      });
      initialMediumCirclePositions.forEach(pos => {
        ctx.fillStyle = "rgba(43,43,43,1)";
        ctx.beginPath();
        ctx.arc(pos.x + 7, pos.y + 7, Math.floor(circleRadius * 0.75), 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = selectedColor;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, Math.floor(circleRadius * 0.75), 0, Math.PI * 2);
        ctx.fill();
      });
      initialSmallCirclePositions.forEach(pos => {
        ctx.fillStyle = "rgba(43,43,43,1)";
        ctx.beginPath();
        ctx.arc(pos.x + 7, pos.y + 7, smallCircleRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = selectedColor;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, smallCircleRadius, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.restore();
    }

    function drawCircles() {
      circleInstances.forEach(circle => {
        ctx.fillStyle = circle.color;
        ctx.beginPath();
        ctx.arc(circle.pos.x, circle.pos.y, circle.radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawSelectedCircleBorder(circle) {
      if (toggleBorderOn) {
        ctx.strokeStyle = "rgb(" + colorSwatches[currentSwatchIndex].join(",") + ")";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(circle.pos.x, circle.pos.y, circle.radius + 4, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    // Draw a simple colour indicator.
    function drawColorIndicator() {
      let pos = { x: 450, y: 810 };
      let col = colorSwatches[currentSwatchIndex];
      ctx.fillStyle = "rgb(" + col.join(",") + ")";
      // Draw as a rounded square.
      drawRoundedRect(pos.x, pos.y, 20, 20, 3, 3, 3, 3);
      ctx.strokeStyle = "rgb(255,255,255)";
      ctx.strokeRect(pos.x, pos.y, 20, 20);
    }

    function draw() {
      ctx.clearRect(0, 0, DESIGN_WIDTH, DESIGN_HEIGHT);
      // Draw main drawing area (left side) with the current pattern.
      ctx.drawImage(checkerboardImg, backgroundX, backgroundY);
      // Draw the sidebar background with rounded right edges for a minimal look.
      ctx.fillStyle = "#f0f0f0";
      // Rounded only on the top-right and bottom-right corners.
      drawRoundedRect(DESIGN_WIDTH - SIDEBAR_WIDTH, 0, SIDEBAR_WIDTH, DESIGN_HEIGHT, 0, 15, 15, 0);
      // Draw vertical border between main area and sidebar.
      ctx.strokeStyle = "rgb(23,23,23)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(MAIN_AREA_WIDTH, 0);
      ctx.lineTo(MAIN_AREA_WIDTH, DESIGN_HEIGHT);
      ctx.stroke();

      // Draw the SPPE by JLW text at the top of the sidebar.
      ctx.fillStyle = "rgb(90,90,90)";
      ctx.font = "bold 12px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText("SPPE by JLW", DESIGN_WIDTH - SIDEBAR_WIDTH/2, 10);

      drawInitialCircles();
      drawCircles();
      if (dragging && draggedItem) drawSelectedCircleBorder(draggedItem);
      drawColorSwatches();
      drawColorIndicator();
      drawButton(resetButton);
      drawButton(resetBgButton);
      // If a circle is being dragged over the delete button, override its colour to red.
      if (dragging && draggedItem &&
          draggedItem.pos.x >= deleteButton.x &&
          draggedItem.pos.x <= deleteButton.x + deleteButton.w &&
          draggedItem.pos.y >= deleteButton.y &&
          draggedItem.pos.y <= deleteButton.y + deleteButton.h) {
        drawButton(deleteButton, "rgb(255,0,0)");
      } else {
        drawButton(deleteButton);
      }
      drawButton(randomButton);
      drawButton(saveButton);
      drawButton(backgroundButton);
      switchButtons.forEach(btn => drawButton(btn));
      drawButton(toggleDragButton);
      drawToggleButton();
    }

    function loop() {
      draw();
      requestAnimationFrame(loop);
    }
    loop();

    // ------------------------------------------------------------
    // Save only the main drawing area (left side) as an image.
    // ------------------------------------------------------------
    function saveMainImage() {
      let offCanvas = document.createElement("canvas");
      offCanvas.width = MAIN_AREA_WIDTH;
      offCanvas.height = DESIGN_HEIGHT;
      let offCtx = offCanvas.getContext("2d");
      offCtx.drawImage(canvas, 0, 0, MAIN_AREA_WIDTH, DESIGN_HEIGHT, 0, 0, MAIN_AREA_WIDTH, DESIGN_HEIGHT);
      const link = document.createElement('a');
      link.download = 'SPPE.png';
      link.href = offCanvas.toDataURL();
      link.click();
    }

    // ------------------------------------------------------------
    // Mouse Event Handling (adjusting for scale)
    // ------------------------------------------------------------
    canvas.addEventListener("mousedown", function (e) {
      const rect = canvas.getBoundingClientRect();
      // Convert the client coordinates to design coordinates
      const mouseX = (e.clientX - rect.left) / currentScale;
      const mouseY = (e.clientY - rect.top) / currentScale;
      // Add this snippet inside the canvas mousedown event handler, immediately after calculating mouseX and mouseY:
if (
  mouseX >= (DESIGN_WIDTH - SIDEBAR_WIDTH / 2 - 50) &&
  mouseX <= (DESIGN_WIDTH - SIDEBAR_WIDTH / 2 + 50) &&
  mouseY >= 10 && mouseY <= 26
) {
  window.open("https://jlw.kleio.com", "_blank");
  return;
}

      // Check toggle border button.
      if (mouseX >= toggleBorderButton.x && mouseX <= toggleBorderButton.x + toggleBorderButton.w &&
          mouseY >= toggleBorderButton.y && mouseY <= toggleBorderButton.y + toggleBorderButton.h) {
        toggleBorderOn = !toggleBorderOn;
        return;
      }
      // Check toggle drag button.
      if (mouseX >= toggleDragButton.x && mouseX <= toggleDragButton.x + toggleDragButton.w &&
          mouseY >= toggleDragButton.y && mouseY <= toggleDragButton.y + toggleDragButton.h) {
        toggleDragEnabled = !toggleDragEnabled;
        toggleDragButton.label = toggleDragEnabled ? "BG Move On" : "BG Move Off";
        return;
      }
      // Pattern switch buttons.
      for (let btn of switchButtons) {
        if (mouseX >= btn.x && mouseX <= btn.x + btn.w &&
            mouseY >= btn.y && mouseY <= btn.y + btn.h) {
          switchToPattern(btn.patternNumber);
          return;
        }
      }
      // Reset background button.
      if (mouseX >= resetBgButton.x && mouseX <= resetBgButton.x + resetBgButton.w &&
          mouseY >= resetBgButton.y && mouseY <= resetBgButton.y + resetBgButton.h) {
        backgroundX = 0; backgroundY = 0;
        return;
      }
      // Colour swatches.
      for (let i = 0; i < swatchPositions.length; i++) {
        let pos = swatchPositions[i];
        if (mouseX >= pos.x && mouseX <= pos.x + swatchWidth &&
            mouseY >= pos.y && mouseY <= pos.y + swatchHeight) {
          selectedColor = "rgb(" + colorSwatches[i].join(",") + ")";
          currentSwatchIndex = i;
          return;
        }
      }
      // Reset button (clear circles).
      if (mouseX >= resetButton.x && mouseX <= resetButton.x + resetButton.w &&
          mouseY >= resetButton.y && mouseY <= resetButton.y + resetButton.h) {
        circleInstances = [];
        return;
      }
      // Save button (save only main area).
      if (mouseX >= saveButton.x && mouseX <= saveButton.x + saveButton.w &&
          mouseY >= saveButton.y && mouseY <= saveButton.y + saveButton.h) {
        saveMainImage();
        return;
      }
      // Random button (add circles).
      if (mouseX >= randomButton.x && mouseX <= randomButton.x + randomButton.w &&
          mouseY >= randomButton.y && mouseY <= randomButton.y + randomButton.h) {
        addRandomCircles();
        return;
      }
      // Background button (new pattern).
      if (mouseX >= backgroundButton.x && mouseX <= backgroundButton.x + backgroundButton.w &&
          mouseY >= backgroundButton.y && mouseY <= backgroundButton.y + backgroundButton.h) {
        createNewPattern();
        return;
      }
      // Check initial preset circles – if clicked, add a new circle and start dragging it.
      let found = false;
      function checkInitial(pos, size) {
        const dx = mouseX - pos.x, dy = mouseY - pos.y;
        if (dx * dx + dy * dy <= size * size) {
          const newCircle = { color: selectedColor, pos: { x: mouseX, y: mouseY }, radius: size };
          circleInstances.push(newCircle);
          draggedItem = newCircle;
          dragging = true;
          found = true;
        }
      }
      [initialCirclePositions, initialMediumCirclePositions, initialSmallCirclePositions].forEach(arr => {
        if (!found) arr.forEach(pos => { if (!found) checkInitial(pos, (arr === initialSmallCirclePositions) ? smallCircleRadius : (arr === initialMediumCirclePositions ? Math.floor(circleRadius * 0.75) : circleRadius)); });
      });
      if (found) return;
      // Check existing circles (from top).
      for (let i = circleInstances.length - 1; i >= 0; i--) {
        const circle = circleInstances[i];
        const dx = mouseX - circle.pos.x, dy = mouseY - circle.pos.y;
        if (dx * dx + dy * dy <= circle.radius * circle.radius) {
          draggedItem = circle;
          dragging = true;
          offsetX = mouseX - circle.pos.x;
          offsetY = mouseY - circle.pos.y;
          return;
        }
      }
      // Otherwise, if dragging is enabled, start dragging the background.
      if (toggleDragEnabled) {
        dragging = true;
        draggedItem = null;
      }
    });

    canvas.addEventListener("mousemove", function (e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left) / currentScale;
      const mouseY = (e.clientY - rect.top) / currentScale;
      if (dragging) {
        if (draggedItem) {
          draggedItem.pos.x = mouseX - offsetX;
          draggedItem.pos.y = mouseY - offsetY;
        } else if (toggleDragEnabled) {
          backgroundX += e.movementX / currentScale;
          backgroundY += e.movementY / currentScale;
        }
      }
    });

    canvas.addEventListener("mouseup", function (e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left) / currentScale;
      const mouseY = (e.clientY - rect.top) / currentScale;
      if (dragging && draggedItem) {
        if (mouseX >= deleteButton.x && mouseX <= deleteButton.x + deleteButton.w &&
            mouseY >= deleteButton.y && mouseY <= deleteButton.y + deleteButton.h) {
          const index = circleInstances.indexOf(draggedItem);
          if (index > -1) circleInstances.splice(index, 1);
        }
      }
      dragging = false;
      draggedItem = null;
    });

    // ------------------------------------------------------------
    // Touch Event Handling (mirroring mouse events, with BG move support)
    // ------------------------------------------------------------
    canvas.addEventListener("touchstart", function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mouseX = (touch.clientX - rect.left) / currentScale;
      const mouseY = (touch.clientY - rect.top) / currentScale;

      // Check toggle border button.
      if (mouseX >= toggleBorderButton.x && mouseX <= toggleBorderButton.x + toggleBorderButton.w &&
          mouseY >= toggleBorderButton.y && mouseY <= toggleBorderButton.y + toggleBorderButton.h) {
        toggleBorderOn = !toggleBorderOn;
        return;
      }
      // Check toggle drag button.
      if (mouseX >= toggleDragButton.x && mouseX <= toggleDragButton.x + toggleDragButton.w &&
          mouseY >= toggleDragButton.y && mouseY <= toggleDragButton.y + toggleDragButton.h) {
        toggleDragEnabled = !toggleDragEnabled;
        toggleDragButton.label = toggleDragEnabled ? "BG Move On" : "BG Move Off";
        return;
      }
      // Pattern switch buttons.
      for (let btn of switchButtons) {
        if (mouseX >= btn.x && mouseX <= btn.x + btn.w &&
            mouseY >= btn.y && mouseY <= btn.y + btn.h) {
          switchToPattern(btn.patternNumber);
          return;
        }
      }
      // Reset background button.
      if (mouseX >= resetBgButton.x && mouseX <= resetBgButton.x + resetBgButton.w &&
          mouseY >= resetBgButton.y && mouseY <= resetBgButton.y + resetBgButton.h) {
        backgroundX = 0; backgroundY = 0;
        return;
      }
      // Colour swatches.
      for (let i = 0; i < swatchPositions.length; i++) {
        let pos = swatchPositions[i];
        if (mouseX >= pos.x && mouseX <= pos.x + swatchWidth &&
            mouseY >= pos.y && mouseY <= pos.y + swatchHeight) {
          selectedColor = "rgb(" + colorSwatches[i].join(",") + ")";
          currentSwatchIndex = i;
          return;
        }
      }
      // Reset button (clear circles).
      if (mouseX >= resetButton.x && mouseX <= resetButton.x + resetButton.w &&
          mouseY >= resetButton.y && mouseY <= resetButton.y + resetButton.h) {
        circleInstances = [];
        return;
      }
      // Save button (save only main area).
      if (mouseX >= saveButton.x && mouseX <= saveButton.x + saveButton.w &&
          mouseY >= saveButton.y && mouseY <= saveButton.y + saveButton.h) {
        saveMainImage();
        return;
      }
      // Random button (add circles).
      if (mouseX >= randomButton.x && mouseX <= randomButton.x + randomButton.w &&
          mouseY >= randomButton.y && mouseY <= randomButton.y + randomButton.h) {
        addRandomCircles();
        return;
      }
      // Background button (new pattern).
      if (mouseX >= backgroundButton.x && mouseX <= backgroundButton.x + backgroundButton.w &&
          mouseY >= backgroundButton.y && mouseY <= backgroundButton.y + backgroundButton.h) {
        createNewPattern();
        return;
      }
      // Check initial preset circles.
      let found = false;
      function checkInitial(pos, size) {
        const dx = mouseX - pos.x, dy = mouseY - pos.y;
        if (dx * dx + dy * dy <= size * size) {
          const newCircle = { color: selectedColor, pos: { x: mouseX, y: mouseY }, radius: size };
          circleInstances.push(newCircle);
          draggedItem = newCircle;
          dragging = true;
          found = true;
        }
      }
      [initialCirclePositions, initialMediumCirclePositions, initialSmallCirclePositions].forEach(arr => {
        if (!found) arr.forEach(pos => { if (!found) checkInitial(pos, (arr === initialSmallCirclePositions) ? smallCircleRadius : (arr === initialMediumCirclePositions ? Math.floor(circleRadius * 0.75) : circleRadius)); });
      });
      if (found) return;
      // Check existing circles.
      for (let i = circleInstances.length - 1; i >= 0; i--) {
        const circle = circleInstances[i];
        const dx = mouseX - circle.pos.x, dy = mouseY - circle.pos.y;
        if (dx * dx + dy * dy <= circle.radius * circle.radius) {
          draggedItem = circle;
          dragging = true;
          offsetX = mouseX - circle.pos.x;
          offsetY = mouseY - circle.pos.y;
          return;
        }
      }
      // If BG move is enabled, start dragging background and record the starting touch.
      if (toggleDragEnabled) {
        dragging = true;
        draggedItem = null;
        lastTouchX = mouseX;
        lastTouchY = mouseY;
      }
    }, {passive: false});

    canvas.addEventListener("touchmove", function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mouseX = (touch.clientX - rect.left) / currentScale;
      const mouseY = (touch.clientY - rect.top) / currentScale;
      if (dragging) {
        if (draggedItem) {
          draggedItem.pos.x = mouseX - offsetX;
          draggedItem.pos.y = mouseY - offsetY;
        } else if (toggleDragEnabled) {
          // Compute movement delta using last recorded touch positions.
          if (lastTouchX !== null && lastTouchY !== null) {
            let deltaX = mouseX - lastTouchX;
            let deltaY = mouseY - lastTouchY;
            backgroundX += deltaX;
            backgroundY += deltaY;
          }
          lastTouchX = mouseX;
          lastTouchY = mouseY;
        }
      }
    }, {passive: false});

    canvas.addEventListener("touchend", function(e) {
      e.preventDefault();
      const touch = e.changedTouches[0];
      const rect = canvas.getBoundingClientRect();
      const mouseX = (touch.clientX - rect.left) / currentScale;
      const mouseY = (touch.clientY - rect.top) / currentScale;
      if (dragging && draggedItem) {
        if (mouseX >= deleteButton.x && mouseX <= deleteButton.x + deleteButton.w &&
            mouseY >= deleteButton.y && mouseY <= deleteButton.y + deleteButton.h) {
          const index = circleInstances.indexOf(draggedItem);
          if (index > -1) circleInstances.splice(index, 1);
        }
      }
      dragging = false;
      draggedItem = null;
      lastTouchX = null;
      lastTouchY = null;
    }, {passive: false});

    window.addEventListener("keydown", function (e) {
      switch (e.key) {
        case "ArrowUp": backgroundY -= 200; break;
        case "ArrowDown": backgroundY += 200; break;
        case "ArrowLeft": backgroundX -= 10; break;
        case "ArrowRight": backgroundX += 10; break;
        case "f":
        case "F":
          if (draggedItem) {
            const index = circleInstances.indexOf(draggedItem);
            if (index > -1) {
              circleInstances.splice(index, 1);
              circleInstances.push(draggedItem);
            }
          }
          break;
        case "b":
        case "B":
          if (draggedItem) {
            const index = circleInstances.indexOf(draggedItem);
            if (index > -1) {
              circleInstances.splice(index, 1);
              circleInstances.unshift(draggedItem);
            }
          }
          break;
        case "n":
        case "N":
          if (draggedItem) {
            const index = circleInstances.indexOf(draggedItem);
            if (index < circleInstances.length - 1) {
              [circleInstances[index], circleInstances[index + 1]] = [circleInstances[index + 1], circleInstances[index]];
            }
          }
          break;
        case "m":
        case "M":
          if (draggedItem) {
            const index = circleInstances.indexOf(draggedItem);
            if (index > 0) {
              [circleInstances[index], circleInstances[index - 1]] = [circleInstances[index - 1], circleInstances[index]];
            }
          }
          break;
        case "Backspace":
        case "Delete":
          if (draggedItem) {
            const index = circleInstances.indexOf(draggedItem);
            if (index > -1) {
              circleInstances.splice(index, 1);
              draggedItem = null;
            }
          }
          break;
        case "l":
        case "L":
          toggleDragEnabled = !toggleDragEnabled;
          toggleDragButton.label = toggleDragEnabled ? "BG Move On" : "BG Move Off";
          break;
        case "s":
        case "S":
          currentSwatchIndex = (currentSwatchIndex + 1) % colorSwatches.length;
          break;
        case "d":
        case "D":
          toggleBorderOn = !toggleBorderOn;
          break;
        case "q":
        case "Q":
          window.close();
          break;
      }
    });

    // ------------------------------------------------------------
    // Scale the canvas to fit the screen on mobile devices.
    // Instead of using a transform, we adjust the canvas style width and height.
    // ------------------------------------------------------------
function scaleCanvas() {
    let scale = Math.min(window.innerWidth / DESIGN_WIDTH, window.innerHeight / DESIGN_HEIGHT);
    if (window.innerWidth < 600) {
        scale *= 1.2;
    }
    currentScale = scale;
    canvas.style.width = (DESIGN_WIDTH * currentScale) + 'px';
    canvas.style.height = (DESIGN_HEIGHT * currentScale) + 'px';
}
window.addEventListener('resize', scaleCanvas);
scaleCanvas();

  </script>
</body>
</html>
